# BeamerParts - Phase 3: Order Processing & Payment

## Phase Overview

**Objective**: Implement complete order processing workflow with payment integration and guest checkout functionality

**Duration**: 4-5 weeks

**Scope**: Build the Order Service as a new microservice to handle the complete purchase workflow, integrate Stripe payment processing, implement Romanian legal-compliant invoice generation, enable guest checkout with email-based ordering, and create comprehensive order management with cross-service coordination.

## Core Requirements

### Functional Requirements
- Complete Order Service implementation as an independent microservice
- Stripe payment integration with webhook handling for secure payment processing
- Guest checkout functionality allowing purchases without account registration
- Professional invoice generation complying with Romanian fiscal regulations
- Order status tracking with automated transitions and customer notifications
- Cross-service inventory coordination for order fulfillment
- Email notification system with order confirmations and status updates
- Order history and tracking for both registered users and guest customers
- Comprehensive error handling for payment failures and order issues

### Technical Requirements
- New Order Service with separate PostgreSQL database
- Stripe API integration with secure webhook handling
- PDF invoice generation with professional formatting and legal compliance
- Email service integration with templated notifications
- Event-driven architecture for order state changes and inventory updates
- Order data synchronization across User, Product, and Vehicle services
- Robust error handling and retry mechanisms for payment processing
- Performance optimization for order processing workflows

## Order Service Database Architecture

### Core Order Management Tables
```sql
-- Main orders table
orders (
    id BIGINT PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
    order_number VARCHAR(50) NOT NULL UNIQUE, -- ORD-2025-000001
    user_id BIGINT, -- NULL for guest orders
    guest_email VARCHAR(255), -- Required for guest orders
    guest_first_name VARCHAR(100),
    guest_last_name VARCHAR(100),
    guest_phone VARCHAR(20),
    
    -- Order totals
    subtotal DECIMAL(10,2) NOT NULL,
    tax_amount DECIMAL(10,2) NOT NULL DEFAULT 0,
    shipping_amount DECIMAL(10,2) NOT NULL DEFAULT 0,
    discount_amount DECIMAL(10,2) NOT NULL DEFAULT 0,
    total_amount DECIMAL(10,2) NOT NULL,
    currency VARCHAR(3) NOT NULL DEFAULT 'RON',
    
    -- Order status and tracking
    status VARCHAR(20) NOT NULL DEFAULT 'PENDING',
    payment_status VARCHAR(20) NOT NULL DEFAULT 'PENDING',
    fulfillment_status VARCHAR(20) NOT NULL DEFAULT 'PENDING',
    
    -- Addresses
    billing_address JSONB NOT NULL,
    shipping_address JSONB NOT NULL,
    
    -- Metadata
    order_notes TEXT,
    admin_notes TEXT,
    source VARCHAR(20) DEFAULT 'WEB',
    
    -- Timestamps
    created_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
    shipped_at TIMESTAMP,
    delivered_at TIMESTAMP,
    
    CONSTRAINT ck_orders_user_or_guest CHECK (
        (user_id IS NOT NULL AND guest_email IS NULL) OR 
        (user_id IS NULL AND guest_email IS NOT NULL)
    ),
    CONSTRAINT ck_orders_status CHECK (status IN ('PENDING', 'CONFIRMED', 'PROCESSING', 'SHIPPED', 'DELIVERED', 'CANCELLED', 'REFUNDED')),
    CONSTRAINT ck_orders_payment_status CHECK (payment_status IN ('PENDING', 'PROCESSING', 'COMPLETED', 'FAILED', 'REFUNDED', 'PARTIALLY_REFUNDED')),
    CONSTRAINT ck_orders_fulfillment_status CHECK (fulfillment_status IN ('PENDING', 'PROCESSING', 'PACKED', 'SHIPPED', 'DELIVERED', 'RETURNED')),
    CONSTRAINT ck_orders_amounts CHECK (subtotal >= 0 AND total_amount >= 0)
);

-- Order items
order_items (
    id BIGINT PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
    order_id BIGINT NOT NULL REFERENCES orders(id) ON DELETE CASCADE,
    product_sku VARCHAR(50) NOT NULL,
    variant_sku VARCHAR(20),
    product_name VARCHAR(255) NOT NULL, -- Snapshot at order time
    product_description TEXT,
    quantity INTEGER NOT NULL,
    unit_price DECIMAL(10,2) NOT NULL,
    total_price DECIMAL(10,2) NOT NULL,
    
    -- BMW compatibility info snapshot
    compatible_generations TEXT[], -- ['F30', 'F31'] 
    installation_difficulty VARCHAR(20),
    installation_notes TEXT,
    
    created_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
    
    CONSTRAINT ck_order_items_quantity CHECK (quantity > 0),
    CONSTRAINT ck_order_items_prices CHECK (unit_price >= 0 AND total_price >= 0)
);

-- Order status history
order_status_history (
    id BIGINT PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
    order_id BIGINT NOT NULL REFERENCES orders(id) ON DELETE CASCADE,
    previous_status VARCHAR(20),
    new_status VARCHAR(20) NOT NULL,
    status_type VARCHAR(20) NOT NULL, -- ORDER, PAYMENT, FULFILLMENT
    changed_by_user_id BIGINT, -- Admin user who made the change
    change_reason VARCHAR(100),
    notes TEXT,
    created_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
    
    CONSTRAINT ck_order_status_type CHECK (status_type IN ('ORDER', 'PAYMENT', 'FULFILLMENT'))
);

-- Payment records
payments (
    id BIGINT PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
    order_id BIGINT NOT NULL REFERENCES orders(id) ON DELETE CASCADE,
    payment_intent_id VARCHAR(255) NOT NULL UNIQUE, -- Stripe payment intent ID
    payment_method VARCHAR(50) NOT NULL,
    amount DECIMAL(10,2) NOT NULL,
    currency VARCHAR(3) NOT NULL DEFAULT 'RON',
    status VARCHAR(20) NOT NULL,
    
    -- Stripe metadata
    stripe_payment_id VARCHAR(255),
    stripe_charge_id VARCHAR(255),
    stripe_customer_id VARCHAR(255),
    
    -- Payment details
    card_last_four VARCHAR(4),
    card_brand VARCHAR(20),
    receipt_url TEXT,
    
    -- Timestamps
    created_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
    processed_at TIMESTAMP,
    failed_at TIMESTAMP,
    
    -- Error tracking
    failure_code VARCHAR(50),
    failure_message TEXT,
    
    CONSTRAINT ck_payments_status CHECK (status IN ('PENDING', 'PROCESSING', 'SUCCEEDED', 'FAILED', 'CANCELLED', 'REFUNDED')),
    CONSTRAINT ck_payments_amount CHECK (amount > 0)
);

-- Invoices
invoices (
    id BIGINT PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
    order_id BIGINT NOT NULL REFERENCES orders(id) ON DELETE CASCADE,
    invoice_number VARCHAR(50) NOT NULL UNIQUE, -- INV-2025-000001
    
    -- Company information (Romanian legal requirements)
    company_name VARCHAR(200) NOT NULL DEFAULT 'BeamerParts SRL',
    company_address TEXT NOT NULL,
    company_cui VARCHAR(20) NOT NULL, -- Romanian tax number
    company_reg_number VARCHAR(50) NOT NULL, -- Trade registry number
    company_vat_number VARCHAR(20),
    
    -- Customer information
    customer_name VARCHAR(200) NOT NULL,
    customer_email VARCHAR(255) NOT NULL,
    customer_address TEXT NOT NULL,
    customer_cui VARCHAR(20), -- For business customers
    
    -- Invoice details
    issue_date DATE NOT NULL DEFAULT CURRENT_DATE,
    due_date DATE NOT NULL,
    subtotal DECIMAL(10,2) NOT NULL,
    vat_rate DECIMAL(5,2) NOT NULL DEFAULT 19.00, -- Romanian VAT
    vat_amount DECIMAL(10,2) NOT NULL,
    total_amount DECIMAL(10,2) NOT NULL,
    currency VARCHAR(3) NOT NULL DEFAULT 'RON',
    
    -- Invoice status
    status VARCHAR(20) NOT NULL DEFAULT 'DRAFT',
    
    -- PDF storage
    pdf_generated BOOLEAN DEFAULT false,
    pdf_file_path VARCHAR(500),
    pdf_generated_at TIMESTAMP,
    
    -- Timestamps
    created_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
    
    CONSTRAINT ck_invoices_status CHECK (status IN ('DRAFT', 'SENT', 'PAID', 'OVERDUE', 'CANCELLED')),
    CONSTRAINT ck_invoices_dates CHECK (due_date >= issue_date),
    CONSTRAINT ck_invoices_amounts CHECK (subtotal >= 0 AND total_amount >= 0)
);

-- Shipping information
shipping_records (
    id BIGINT PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
    order_id BIGINT NOT NULL REFERENCES orders(id) ON DELETE CASCADE,
    carrier VARCHAR(100),
    tracking_number VARCHAR(100),
    tracking_url TEXT,
    shipping_method VARCHAR(50),
    estimated_delivery_date DATE,
    actual_delivery_date DATE,
    
    -- Shipping costs
    shipping_cost DECIMAL(10,2) DEFAULT 0,
    insurance_cost DECIMAL(10,2) DEFAULT 0,
    
    -- Package details
    package_weight_grams INTEGER,
    package_dimensions JSONB, -- {"length": 30, "width": 20, "height": 15}
    
    -- Status tracking
    shipping_status VARCHAR(20) DEFAULT 'PENDING',
    
    -- Timestamps
    shipped_at TIMESTAMP,
    delivered_at TIMESTAMP,
    created_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
    
    CONSTRAINT ck_shipping_status CHECK (shipping_status IN ('PENDING', 'PICKED_UP', 'IN_TRANSIT', 'OUT_FOR_DELIVERY', 'DELIVERED', 'FAILED_DELIVERY', 'RETURNED'))
);

-- Order discounts and promotions
order_discounts (
    id BIGINT PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
    order_id BIGINT NOT NULL REFERENCES orders(id) ON DELETE CASCADE,
    discount_type VARCHAR(50) NOT NULL,
    discount_code VARCHAR(50),
    discount_description VARCHAR(200),
    discount_amount DECIMAL(10,2) NOT NULL,
    discount_percentage DECIMAL(5,2),
    
    created_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
    
    CONSTRAINT ck_order_discounts_amount CHECK (discount_amount >= 0),
    CONSTRAINT ck_order_discounts_type CHECK (discount_type IN ('PERCENTAGE', 'FIXED_AMOUNT', 'FREE_SHIPPING', 'BULK_DISCOUNT'))
);

-- Guest order tracking (for account linking)
guest_order_tracking (
    id BIGINT PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
    guest_email VARCHAR(255) NOT NULL,
    order_id BIGINT NOT NULL REFERENCES orders(id) ON DELETE CASCADE,
    access_token VARCHAR(255) NOT NULL UNIQUE, -- For guest order tracking
    token_expires_at TIMESTAMP NOT NULL,
    
    created_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
    
    CONSTRAINT ck_guest_token_expiry CHECK (token_expires_at > created_at)
);
```

### Database Indexes for Performance
```sql
-- Order Service Performance Indexes
CREATE INDEX idx_orders_user_id ON orders(user_id);
CREATE INDEX idx_orders_guest_email ON orders(guest_email);
CREATE INDEX idx_orders_status ON orders(status);
CREATE INDEX idx_orders_payment_status ON orders(payment_status);
CREATE INDEX idx_orders_created_at ON orders(created_at);
CREATE INDEX idx_orders_order_number ON orders(order_number);

CREATE INDEX idx_order_items_order_id ON order_items(order_id);
CREATE INDEX idx_order_items_product_sku ON order_items(product_sku);

CREATE INDEX idx_payments_order_id ON payments(order_id);
CREATE INDEX idx_payments_payment_intent_id ON payments(payment_intent_id);
CREATE INDEX idx_payments_status ON payments(status);

CREATE INDEX idx_invoices_order_id ON invoices(order_id);
CREATE INDEX idx_invoices_invoice_number ON invoices(invoice_number);
CREATE INDEX idx_invoices_status ON invoices(status);

CREATE INDEX idx_shipping_records_order_id ON shipping_records(order_id);
CREATE INDEX idx_shipping_records_tracking_number ON shipping_records(tracking_number);

CREATE INDEX idx_guest_order_tracking_email ON guest_order_tracking(guest_email);
CREATE INDEX idx_guest_order_tracking_token ON guest_order_tracking(access_token);
```

## Order Service API Architecture

### Core Order Management Endpoints
```http
# Order Creation and Management
POST   /internal/orders                          # Create new order
GET    /internal/orders/{orderId}                # Get order details
PUT    /internal/orders/{orderId}/status         # Update order status
GET    /internal/orders/user/{userId}            # Get user's orders
GET    /internal/orders/guest/{email}            # Get guest orders

# Guest Order Management
POST   /internal/orders/guest                    # Guest checkout
GET    /internal/orders/guest/track/{token}      # Track guest order
POST   /internal/orders/guest/link-to-account    # Link guest orders to account

# Payment Processing
POST   /internal/orders/{orderId}/payment/intent # Create payment intent
POST   /internal/orders/payment/webhook          # Stripe webhook handler
GET    /internal/orders/{orderId}/payment/status # Get payment status
POST   /internal/orders/{orderId}/payment/refund # Process refund

# Invoice Management
GET    /internal/orders/{orderId}/invoice        # Get invoice details
POST   /internal/orders/{orderId}/invoice/generate # Generate PDF invoice
POST   /internal/orders/{orderId}/invoice/send   # Send invoice via email
GET    /internal/orders/{orderId}/invoice/pdf    # Download PDF invoice

# Shipping and Fulfillment
PUT    /internal/orders/{orderId}/shipping       # Update shipping info
POST   /internal/orders/{orderId}/ship           # Mark as shipped
PUT    /internal/orders/{orderId}/tracking       # Update tracking info

# Order Search and Filtering
GET    /internal/orders/search                   # Search orders with filters
GET    /internal/orders/status/{status}          # Get orders by status
GET    /internal/orders/date-range               # Get orders by date range
```

### Public API Endpoints (via API Gateway)
```http
# Customer Order Management
GET    /api/orders                               # Get user's orders
GET    /api/orders/{orderId}                     # Get specific order
POST   /api/orders/checkout                      # Create order from cart
GET    /api/orders/{orderId}/track               # Track order status

# Guest Order Operations
POST   /api/orders/guest/checkout                # Guest checkout
GET    /api/orders/guest/track/{token}           # Guest order tracking
POST   /api/orders/guest/send-tracking          # Send tracking email

# Payment Operations
POST   /api/orders/{orderId}/payment             # Process payment
GET    /api/orders/{orderId}/payment/status      # Check payment status

# Invoice Operations
GET    /api/orders/{orderId}/invoice             # Get invoice
GET    /api/orders/{orderId}/invoice/download    # Download PDF invoice
```

## Order Processing Workflow Implementation

### Comprehensive Order Service
```java
@Service
@Transactional
public class OrderProcessingService {
    
    @Autowired
    private OrderRepository orderRepository;
    
    @Autowired
    private PaymentService paymentService;
    
    @Autowired
    private InvoiceService invoiceService;
    
    @Autowired
    private UserServiceClient userServiceClient;
    
    @Autowired
    private ProductServiceClient productServiceClient;
    
    @Autowired
    private NotificationService notificationService;
    
    @Autowired
    private OrderEventPublisher eventPublisher;
    
    public OrderCreationResult createOrderFromCart(OrderCreationRequest request) {
        try {
            // 1. Validate cart and get current state
            CartValidationResult cartValidation = validateCartForCheckout(request);
            if (!cartValidation.isValid()) {
                return OrderCreationResult.failed(cartValidation.getErrors());
            }
            
            // 2. Calculate final order totals
            OrderCalculationResult orderCalculation = calculateOrderTotals(
                    cartValidation.getCartItems(), request);
            
            // 3. Create order entity
            Order order = createOrderEntity(request, orderCalculation);
            
            // 4. Reserve inventory across Product Service
            InventoryReservationResult reservation = reserveInventoryForOrder(
                    order.getOrderItems());
            if (!reservation.isSuccessful()) {
                return OrderCreationResult.failed("Insufficient inventory for some items");
            }
            
            // 5. Save order to database
            Order savedOrder = orderRepository.save(order);
            
            // 6. Create payment intent with Stripe
            PaymentIntentResult paymentIntent = paymentService.createPaymentIntent(
                    savedOrder, request.getPaymentMethodId());
            
            // 7. Generate invoice
            Invoice invoice = invoiceService.generateInvoice(savedOrder);
            
            // 8. Clear user's cart
            clearUserCart(request.getUserId(), request.getSessionId());
            
            // 9. Publish order created event
            eventPublisher.publishOrderCreated(savedOrder, reservation);
            
            // 10. Send order confirmation
            notificationService.sendOrderConfirmation(savedOrder, invoice);
            
            return OrderCreationResult.success(savedOrder, paymentIntent, invoice);
            
        } catch (Exception e) {
            log.error("Failed to create order for request: {}", request, e);
            // Rollback any reservations
            rollbackOrderCreation(request);
            throw new OrderCreationException("Failed to create order", e);
        }
    }
    
    @Retryable(value = {ServiceUnavailableException.class}, maxAttempts = 3)
    private CartValidationResult validateCartForCheckout(OrderCreationRequest request) {
        if (request.isGuestCheckout()) {
            return userServiceClient.validateGuestCart(request.getSessionId());
        } else {
            return userServiceClient.validateUserCart(request.getUserId());
        }
    }
    
    private OrderCalculationResult calculateOrderTotals(List<CartItemDTO> cartItems, 
            OrderCreationRequest request) {
        
        BigDecimal subtotal = cartItems.stream()
                .map(item -> item.getUnitPrice().multiply(BigDecimal.valueOf(item.getQuantity())))
                .reduce(BigDecimal.ZERO, BigDecimal::add);
        
        BigDecimal shippingAmount = calculateShippingCost(cartItems, request.getShippingAddress());
        BigDecimal taxAmount = calculateTax(subtotal, request.getBillingAddress());
        BigDecimal discountAmount = calculateDiscounts(cartItems, request.getDiscountCodes());
        
        BigDecimal totalAmount = subtotal
                .add(shippingAmount)
                .add(taxAmount)
                .subtract(discountAmount);
        
        return OrderCalculationResult.builder()
                .subtotal(subtotal)
                .shippingAmount(shippingAmount)
                .taxAmount(taxAmount)
                .discountAmount(discountAmount)
                .totalAmount(totalAmount)
                .build();
    }
    
    private Order createOrderEntity(OrderCreationRequest request, 
            OrderCalculationResult calculation) {
        
        Order.OrderBuilder builder = Order.builder()
                .orderNumber(generateOrderNumber())
                .subtotal(calculation.getSubtotal())
                .taxAmount(calculation.getTaxAmount())
                .shippingAmount(calculation.getShippingAmount())
                .discountAmount(calculation.getDiscountAmount())
                .totalAmount(calculation.getTotalAmount())
                .currency("RON")
                .status(OrderStatus.PENDING)
                .paymentStatus(PaymentStatus.PENDING)
                .fulfillmentStatus(FulfillmentStatus.PENDING)
                .billingAddress(request.getBillingAddress())
                .shippingAddress(request.getShippingAddress())
                .orderNotes(request.getOrderNotes())
                .source("WEB");
        
        if (request.isGuestCheckout()) {
            builder.guestEmail(request.getGuestEmail())
                   .guestFirstName(request.getGuestFirstName())
                   .guestLastName(request.getGuestLastName())
                   .guestPhone(request.getGuestPhone());
        } else {
            builder.userId(request.getUserId());
        }
        
        Order order = builder.build();
        
        // Add order items
        List<OrderItem> orderItems = request.getCartItems().stream()
                .map(cartItem -> createOrderItem(order, cartItem))
                .collect(Collectors.toList());
        
        order.setOrderItems(orderItems);
        
        return order;
    }
}
```

### Stripe Payment Integration
```java
@Service
public class StripePaymentService {
    
    @Value("${stripe.secret-key}")
    private String stripeSecretKey;
    
    @Value("${stripe.webhook-secret}")
    private String webhookSecret;
    
    @PostConstruct
    public void init() {
        Stripe.apiKey = stripeSecretKey;
    }
    
    public PaymentIntentResult createPaymentIntent(Order order, String paymentMethodId) {
        try {
            PaymentIntentCreateParams params = PaymentIntentCreateParams.builder()
                    .setAmount(order.getTotalAmount().multiply(BigDecimal.valueOf(100)).longValue()) // Convert to bani
                    .setCurrency("ron")
                    .setPaymentMethod(paymentMethodId)
                    .setConfirmationMethod(PaymentIntentCreateParams.ConfirmationMethod.MANUAL)
                    .setConfirm(true)
                    .setReturnUrl("https://beamerparts.ro/orders/" + order.getId() + "/confirmation")
                    .putMetadata("orderId", order.getId().toString())
                    .putMetadata("orderNumber", order.getOrderNumber())
                    .putMetadata("customerEmail", getCustomerEmail(order))
                    .setDescription("Order " + order.getOrderNumber() + " - BeamerParts")
                    .build();
            
            PaymentIntent intent = PaymentIntent.create(params);
            
            // Save payment record
            Payment payment = createPaymentRecord(order, intent);
            paymentRepository.save(payment);
            
            return PaymentIntentResult.builder()
                    .paymentIntentId(intent.getId())
                    .clientSecret(intent.getClientSecret())
                    .status(intent.getStatus())
                    .requiresAction("requires_action".equals(intent.getStatus()))
                    .build();
                    
        } catch (StripeException e) {
            log.error("Failed to create payment intent for order {}: {}", order.getId(), e.getMessage(), e);
            throw new PaymentProcessingException("Failed to create payment intent", e);
        }
    }
    
    @EventListener
    public void handleStripeWebhook(HttpServletRequest request, 
            @RequestBody String payload, @RequestHeader("Stripe-Signature") String sigHeader) {
        
        try {
            Event event = Webhook.constructEvent(payload, sigHeader, webhookSecret);
            
            switch (event.getType()) {
                case "payment_intent.succeeded":
                    handlePaymentSucceeded(event);
                    break;
                case "payment_intent.payment_failed":
                    handlePaymentFailed(event);
                    break;
                case "payment_intent.requires_action":
                    handlePaymentRequiresAction(event);
                    break;
                case "charge.dispute.created":
                    handleChargeDispute(event);
                    break;
                default:
                    log.info("Unhandled webhook event type: {}", event.getType());
            }
            
        } catch (JsonSyntaxException | SignatureVerificationException e) {
            log.error("Invalid webhook payload or signature", e);
            throw new WebhookValidationException("Invalid webhook", e);
        }
    }
    
    private void handlePaymentSucceeded(Event event) {
        PaymentIntent paymentIntent = (PaymentIntent) event.getDataObjectDeserializer()
                .getObject().orElse(null);
        
        if (paymentIntent != null) {
            String orderId = paymentIntent.getMetadata().get("orderId");
            
            // Update payment status
            updatePaymentStatus(paymentIntent.getId(), PaymentStatus.COMPLETED);
            
            // Update order status
            orderService.updateOrderStatus(Long.valueOf(orderId), OrderStatus.CONFIRMED);
            
            // Publish payment completed event
            eventPublisher.publishPaymentCompleted(orderId, paymentIntent);
            
            // Send payment confirmation email
            notificationService.sendPaymentConfirmation(Long.valueOf(orderId));
        }
    }
}
```

### Invoice Generation Service
```java
@Service
public class InvoiceService {
    
    @Autowired
    private InvoiceRepository invoiceRepository;
    
    @Autowired
    private PDFGenerationService pdfService;
    
    @Autowired
    private FileStorageService fileStorageService;
    
    public Invoice generateInvoice(Order order) {
        // Generate unique invoice number
        String invoiceNumber = generateInvoiceNumber();
        
        Invoice invoice = Invoice.builder()
                .orderId(order.getId())
                .invoiceNumber(invoiceNumber)
                .companyName("BeamerParts SRL")
                .companyAddress("Strada Exemplu 123, Sector 1, București, România")
                .companyCui("RO12345678")
                .companyRegNumber("J40/1234/2025")
                .companyVatNumber("RO12345678")
                .customerName(getCustomerName(order))
                .customerEmail(getCustomerEmail(order))
                .customerAddress(formatAddress(order.getBillingAddress()))
                .issueDate(LocalDate.now())
                .dueDate(LocalDate.now().plusDays(30))
                .subtotal(order.getSubtotal())
                .vatRate(BigDecimal.valueOf(19.00)) // Romanian VAT
                .vatAmount(order.getTaxAmount())
                .totalAmount(order.getTotalAmount())
                .currency("RON")
                .status(InvoiceStatus.DRAFT)
                .build();
        
        Invoice savedInvoice = invoiceRepository.save(invoice);
        
        // Generate PDF asynchronously
        generateInvoicePDFAsync(savedInvoice, order);
        
        return savedInvoice;
    }
    
    @Async
    public void generateInvoicePDFAsync(Invoice invoice, Order order) {
        try {
            // Generate PDF content
            byte[] pdfData = pdfService.generateInvoicePDF(invoice, order);
            
            // Store PDF file
            String fileName = String.format("invoice_%s.pdf", invoice.getInvoiceNumber());
            String filePath = fileStorageService.saveFile(fileName, pdfData, "invoices");
            
            // Update invoice record
            invoice.setPdfGenerated(true);
            invoice.setPdfFilePath(filePath);
            invoice.setPdfGeneratedAt(Instant.now());
            invoiceRepository.save(invoice);
            
            log.info("PDF generated successfully for invoice {}", invoice.getInvoiceNumber());
            
        } catch (Exception e) {
            log.error("Failed to generate PDF for invoice {}", invoice.getInvoiceNumber(), e);
        }
    }
    
    private String generateInvoiceNumber() {
        // Format: INV-YYYY-NNNNNN
        int year = LocalDate.now().getYear();
        Long sequence = invoiceRepository.getNextSequenceForYear(year);
        return String.format("INV-%d-%06d", year, sequence);
    }
}

@Service
public class PDFGenerationService {
    
    public byte[] generateInvoicePDF(Invoice invoice, Order order) {
        try {
            ByteArrayOutputStream outputStream = new ByteArrayOutputStream();
            PdfWriter writer = new PdfWriter(outputStream);
            PdfDocument pdfDoc = new PdfDocument(writer);
            Document document = new Document(pdfDoc);
            
            // Add company header
            addCompanyHeader(document, invoice);
            
            // Add invoice details
            addInvoiceDetails(document, invoice);
            
            // Add customer information
            addCustomerInformation(document, invoice);
            
            // Add order items table
            addOrderItemsTable(document, order);
            
            // Add totals
            addOrderTotals(document, invoice);
            
            // Add legal footer
            addLegalFooter(document, invoice);
            
            document.close();
            
            return outputStream.toByteArray();
            
        } catch (Exception e) {
            log.error("Failed to generate PDF for invoice {}", invoice.getInvoiceNumber(), e);
            throw new PDFGenerationException("Failed to generate invoice PDF", e);
        }
    }
    
    private void addCompanyHeader(Document document, Invoice invoice) {
        // Company logo and information
        Paragraph header = new Paragraph()
                .add(new Text("BEAMERPARTS SRL").setFontSize(18).setBold())
                .add("\n")
                .add(new Text(invoice.getCompanyAddress()).setFontSize(10))
                .add("\n")
                .add(new Text("CUI: " + invoice.getCompanyCui()).setFontSize(10))
                .add("\n")
                .add(new Text("Nr. Reg. Com.: " + invoice.getCompanyRegNumber()).setFontSize(10));
        
        document.add(header);
        document.add(new Paragraph("\n"));
    }
    
    private void addInvoiceDetails(Document document, Invoice invoice) {
        Table invoiceTable = new Table(2);
        invoiceTable.setWidth(UnitValue.createPercentValue(100));
        
        invoiceTable.addCell(new Cell().add(new Paragraph("FACTURĂ").setFontSize(16).setBold()));
        invoiceTable.addCell(new Cell().add(new Paragraph("")));
        
        invoiceTable.addCell(new Cell().add(new Paragraph("Numărul facturii:")));
        invoiceTable.addCell(new Cell().add(new Paragraph(invoice.getInvoiceNumber())));
        
        invoiceTable.addCell(new Cell().add(new Paragraph("Data emiterii:")));
        invoiceTable.addCell(new Cell().add(new Paragraph(invoice.getIssueDate().format(DateTimeFormatter.ofPattern("dd.MM.yyyy")))));
        
        invoiceTable.addCell(new Cell().add(new Paragraph("Data scadenței:")));
        invoiceTable.addCell(new Cell().add(new Paragraph(invoice.getDueDate().format(DateTimeFormatter.ofPattern("dd.MM.yyyy")))));
        
        document.add(invoiceTable);
        document.add(new Paragraph("\n"));
    }
}
```

### Guest Checkout Implementation
```java
@Service
public class GuestCheckoutService {
    
    @Autowired
    private GuestOrderTrackingRepository trackingRepository;
    
    @Autowired
    private EmailService emailService;
    
    public GuestCheckoutResult processGuestCheckout(GuestCheckoutRequest request) {
        // 1. Validate guest checkout data
        validateGuestCheckoutRequest(request);
        
        // 2. Create order as guest
        OrderCreationRequest orderRequest = OrderCreationRequest.builder()
                .isGuestCheckout(true)
                .sessionId(request.getSessionId())
                .guestEmail(request.getEmail())
                .guestFirstName(request.getFirstName())
                .guestLastName(request.getLastName())
                .guestPhone(request.getPhone())
                .billingAddress(request.getBillingAddress())
                .shippingAddress(request.getShippingAddress())
                .paymentMethodId(request.getPaymentMethodId())
                .orderNotes(request.getOrderNotes())
                .build();
        
        OrderCreationResult orderResult = orderProcessingService.createOrderFromCart(orderRequest);
        
        if (!orderResult.isSuccessful()) {
            return GuestCheckoutResult.failed(orderResult.getErrorMessage());
        }
        
        // 3. Create guest tracking token
        String trackingToken = generateGuestTrackingToken();
        
        GuestOrderTracking tracking = GuestOrderTracking.builder()
                .guestEmail(request.getEmail())
                .orderId(orderResult.getOrder().getId())
                .accessToken(trackingToken)
                .tokenExpiresAt(Instant.now().plus(90, ChronoUnit.DAYS)) // 90 days
                .build();
        
        trackingRepository.save(tracking);
        
        // 4. Send guest order confirmation with tracking link
        emailService.sendGuestOrderConfirmation(orderResult.getOrder(), 
                orderResult.getInvoice(), trackingToken);
        
        return GuestCheckoutResult.success(orderResult.getOrder(), trackingToken);
    }
    
    public Order trackGuestOrder(String trackingToken) {
        GuestOrderTracking tracking = trackingRepository.findByAccessToken(trackingToken)
                .orElseThrow(() -> new GuestOrderNotFoundException("Invalid tracking token"));
        
        if (tracking.getTokenExpiresAt().isBefore(Instant.now())) {
            throw new GuestOrderExpiredException("Tracking token has expired");
        }
        
        return orderRepository.findById(tracking.getOrderId())
                .orElseThrow(() -> new OrderNotFoundException("Order not found"));
    }
    
    @Transactional
    public AccountLinkingResult linkGuestOrdersToAccount(String email, Long userId) {
        // Find all guest orders for this email
        List<Order> guestOrders = orderRepository.findByGuestEmailAndUserIdIsNull(email);
        
        if (guestOrders.isEmpty()) {
            return AccountLinkingResult.noOrdersFound();
        }
        
        // Link orders to user account
        guestOrders.forEach(order -> {
            order.setUserId(userId);
            order.setGuestEmail(null); // Clear guest email
        });
        
        orderRepository.saveAll(guestOrders);
        
        // Update guest tracking records
        List<GuestOrderTracking> trackingRecords = trackingRepository.findByGuestEmail(email);
        trackingRecords.forEach(tracking -> {
            // Optionally expire guest tracking tokens since they're now linked to account
            tracking.setTokenExpiresAt(Instant.now());
        });
        trackingRepository.saveAll(trackingRecords);
        
        // Send notification about linked orders
        emailService.sendOrdersLinkedNotification(userId, guestOrders.size());
        
        return AccountLinkingResult.success(guestOrders.size());
    }
}
```

## Cross-Service Integration

### Order Event Publishing
```java
@Component
public class OrderEventPublisher {
    
    @Autowired
    private RabbitTemplate rabbitTemplate;
    
    @TransactionalEventListener(phase = TransactionPhase.AFTER_COMMIT)
    public void publishOrderCreated(OrderCreatedEvent event) {
        OrderCreatedMessage message = OrderCreatedMessage.builder()
                .orderId(event.getOrder().getId())
                .orderNumber(event.getOrder().getOrderNumber())
                .userId(event.getOrder().getUserId())
                .guestEmail(event.getOrder().getGuestEmail())
                .totalAmount(event.getOrder().getTotalAmount())
                .orderItems(mapOrderItems(event.getOrder().getOrderItems()))
                .timestamp(Instant.now())
                .build();
        
        rabbitTemplate.convertAndSend("order.created", message);
        
        // Publish inventory reduction event
        publishInventoryReductionEvent(event.getOrder());
    }
    
    private void publishInventoryReductionEvent(Order order) {
        List<InventoryUpdateMessage> inventoryUpdates = order.getOrderItems().stream()
                .map(item -> InventoryUpdateMessage.builder()
                        .productSku(item.getProductSku())
                        .variantSku(item.getVariantSku())
                        .quantityChange(-item.getQuantity()) // Negative for reduction
                        .changeReason("ORDER_PLACED")
                        .referenceId(order.getOrderNumber())
                        .timestamp(Instant.now())
                        .build())
                .collect(Collectors.toList());
        
        rabbitTemplate.convertAndSend("inventory.bulk.update", inventoryUpdates);
    }
    
    @TransactionalEventListener(phase = TransactionPhase.AFTER_COMMIT)
    public void publishPaymentCompleted(PaymentCompletedEvent event) {
        PaymentCompletedMessage message = PaymentCompletedMessage.builder()
                .orderId(event.getOrderId())
                .paymentId(event.getPaymentId())
                .amount(event.getAmount())
                .paymentMethod(event.getPaymentMethod())
                .timestamp(Instant.now())
                .build();
        
        rabbitTemplate.convertAndSend("order.payment.completed", message);
    }
}
```

### Email Notification Service
```java
@Service
public class OrderNotificationService {
    
    @Autowired
    private EmailTemplateService templateService;
    
    @Autowired
    private EmailSenderService emailSender;
    
    public void sendOrderConfirmation(Order order, Invoice invoice) {
        String customerEmail = getCustomerEmail(order);
        String customerName = getCustomerName(order);
        
        EmailTemplate template = templateService.getTemplate("order-confirmation");
        
        Map<String, Object> variables = Map.of(
                "customerName", customerName,
                "orderNumber", order.getOrderNumber(),
                "orderDate", order.getCreatedAt().format(DateTimeFormatter.ofPattern("dd/MM/yyyy HH:mm")),
                "totalAmount", order.getTotalAmount(),
                "currency", order.getCurrency(),
                "orderItems", mapOrderItemsForEmail(order.getOrderItems()),
                "billingAddress", formatAddressForEmail(order.getBillingAddress()),
                "shippingAddress", formatAddressForEmail(order.getShippingAddress()),
                "trackingUrl", generateTrackingUrl(order),
                "invoiceNumber", invoice.getInvoiceNumber(),
                "companyName", "BeamerParts",
                "supportEmail", "support@beamerparts.ro"
        );
        
        EmailMessage message = EmailMessage.builder()
                .to(customerEmail)
                .subject("Confirmarea comenzii #" + order.getOrderNumber())
                .templateId(template.getTemplateId())
                .variables(variables)
                .attachment(EmailAttachment.builder()
                          .filename("factura-" + invoice.getInvoiceNumber() + ".pdf")
                          .contentType("application/pdf")
                          .data(getInvoicePDFData(invoice))
                          .build())
                .build();
        
        emailSender.send(message);
        
        // Log email sent
        logEmailSent(order.getId(), "order-confirmation", customerEmail);
    }
    
    public void sendGuestOrderConfirmation(Order order, Invoice invoice, String trackingToken) {
        String trackingUrl = String.format("https://beamerparts.ro/track-order/%s", trackingToken);
        
        EmailTemplate template = templateService.getTemplate("guest-order-confirmation");
        
        Map<String, Object> variables = Map.of(
                "customerName", order.getGuestFirstName() + " " + order.getGuestLastName(),
                "orderNumber", order.getOrderNumber(),
                "trackingUrl", trackingUrl,
                "trackingToken", trackingToken,
                "orderDate", order.getCreatedAt().format(DateTimeFormatter.ofPattern("dd/MM/yyyy HH:mm")),
                "totalAmount", order.getTotalAmount(),
                "orderItems", mapOrderItemsForEmail(order.getOrderItems()),
                "createAccountUrl", "https://beamerparts.ro/register?email=" + order.getGuestEmail()
        );
        
        EmailMessage message = EmailMessage.builder()
                .to(order.getGuestEmail())
                .subject("Confirmarea comenzii #" + order.getOrderNumber())
                .templateId(template.getTemplateId())
                .variables(variables)
                .attachment(EmailAttachment.builder()
                          .filename("factura-" + invoice.getInvoiceNumber() + ".pdf")
                          .contentType("application/pdf")
                          .data(getInvoicePDFData(invoice))
                          .build())
                .build();
        
        emailSender.send(message);
    }
    
    public void sendOrderStatusUpdate(Order order, OrderStatus oldStatus, OrderStatus newStatus) {
        String customerEmail = getCustomerEmail(order);
        String statusMessage = getStatusMessage(newStatus);
        
        Map<String, Object> variables = Map.of(
                "customerName", getCustomerName(order),
                "orderNumber", order.getOrderNumber(),
                "oldStatus", oldStatus.getDisplayName(),
                "newStatus", newStatus.getDisplayName(),
                "statusMessage", statusMessage,
                "trackingUrl", generateTrackingUrl(order),
                "estimatedDelivery", calculateEstimatedDelivery(order)
        );
        
        EmailTemplate template = templateService.getTemplate("order-status-update");
        
        EmailMessage message = EmailMessage.builder()
                .to(customerEmail)
                .subject("Actualizare comandă #" + order.getOrderNumber())
                .templateId(template.getTemplateId())
                .variables(variables)
                .build();
        
        emailSender.send(message);
    }
}
```

## Implementation Milestones

### Milestone 1: Order Service Foundation (Week 1)
**Deliverables:**
- Complete Order Service setup with separate database
- Core order management entities and repositories
- Basic order creation and status management
- Order number generation and tracking system
- Database schema implementation with all required tables

**Success Criteria:**
- ✅ Order Service deployable independently
- ✅ Orders can be created and stored correctly
- ✅ Order status transitions working properly
- ✅ Database relationships and constraints functional

### Milestone 2: Payment Integration (Week 2)
**Deliverables:**
- Stripe API integration with payment intents
- Webhook handling for payment status updates
- Payment failure handling and retry mechanisms
- Payment security and fraud prevention
- Payment status tracking and audit trail

**Success Criteria:**
- ✅ Stripe payments processing successfully
- ✅ Webhook events handled reliably
- ✅ Payment failures handled gracefully
- ✅ Payment audit trail complete

### Milestone 3: Guest Checkout & Invoice Generation (Week 3)
**Deliverables:**
- Guest checkout functionality with email-based ordering
- Guest order tracking system with secure tokens
- Professional PDF invoice generation with Romanian compliance
- Guest order linking to accounts when users register
- Legal-compliant invoice formatting and storage

**Success Criteria:**
- ✅ Guest users can complete purchases without registration
- ✅ Guest order tracking functional with secure access
- ✅ Invoices generated with proper Romanian legal formatting
- ✅ Guest orders successfully linked when accounts created

### Milestone 4: Cross-Service Integration (Week 4)
**Deliverables:**
- Order processing workflow integrating all services
- Event-driven inventory updates when orders placed
- Cross-service cart validation and checkout process
- Order confirmation and notification system
- Error handling and rollback mechanisms

**Success Criteria:**
- ✅ Complete checkout process working across all services
- ✅ Inventory automatically updated when orders placed
- ✅ Order confirmations sent reliably
- ✅ Failed orders properly rolled back

### Milestone 5: Advanced Features & Polish (Week 4-5)
**Deliverables:**
- Order search and filtering capabilities
- Advanced order status management
- Shipping integration and tracking
- Order analytics and reporting
- Performance optimization and caching

**Success Criteria:**
- ✅ Order management fully functional for admins
- ✅ Order tracking working for customers
- ✅ Performance optimized for order operations
- ✅ Complete error handling and user feedback

## Success Metrics

### Technical Performance
- **Order Processing Time**: < 2 seconds for complete checkout
- **Payment Processing**: < 5 seconds for Stripe integration
- **Invoice Generation**: < 10 seconds for PDF creation
- **Cross-Service Coordination**: < 500ms for inventory updates

### Business Functionality
- **Payment Success Rate**: > 98% for valid payment methods
- **Order Accuracy**: 100% inventory synchronization
- **Invoice Compliance**: Full Romanian legal requirement compliance
- **Guest Conversion**: Seamless guest-to-account linking

### User Experience
- **Checkout Completion**: Smooth flow for both guest and registered users
- **Order Tracking**: Real-time status updates and notifications
- **Error Recovery**: Clear error messages and recovery options
- **Email Notifications**: Timely and accurate order communications

---

**This Phase 3 implementation creates a complete, production-ready order processing system with secure payment handling, legal-compliant invoicing, and seamless guest checkout functionality while maintaining the distributed microservices architecture.**