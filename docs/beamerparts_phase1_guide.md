# BeamerParts - Phase 1: Microservices Foundation

## Phase Overview

**Objective**: Establish true microservices architecture with independent services and databases

**Duration**: 6-8 weeks (increased due to microservices complexity)

**Scope**: Build three core microservices (User, Vehicle, Product) with separate databases, API Gateway, and inter-service communication patterns that form the foundation for the entire BMW parts e-commerce platform.

## Core Requirements

### Functional Requirements
- Three independent microservices with separate databases
- API Gateway for request routing and cross-cutting concerns
- Inter-service communication via REST APIs and RabbitMQ events
- User registration and authentication with JWT tokens distributed across services
- BMW vehicle hierarchy management with data synchronization
- Product catalog with BMW compatibility using cached vehicle data
- Shopping cart functionality within User Service
- Event-driven data consistency between services

### Technical Requirements
- Spring Boot 3.2+ microservices with proper service boundaries
- Separate PostgreSQL database for each service
- Spring Cloud Gateway for API gateway functionality
- RabbitMQ for asynchronous inter-service communication
- Redis for distributed caching and session management
- Docker Compose for local development environment
- Service discovery and load balancing setup
- Comprehensive error handling and service resilience patterns

## Microservices Architecture

### Service Distribution Overview
```
┌─────────────────────────────────────────────────────────────────┐
│                        API Gateway                             │
│                   (Spring Cloud Gateway)                       │
│                        Port: 8080                              │
│  ┌─────────────┐ ┌─────────────┐ ┌─────────────┐             │
│  │   Auth      │ │   Routing   │ │Rate Limiting│             │
│  │ & Security  │ │ & Discovery │ │& Monitoring │             │
│  └─────────────┘ └─────────────┘ └─────────────┘             │
└─────────────────────────┬───────────────────────────────────────┘
                          │
          ┌───────────────┼───────────────┐
          │               │               │
    ┌─────▼─────┐   ┌─────▼─────┐   ┌─────▼─────┐
    │User Service│   │Vehicle    │   │Product    │
    │Port: 8081  │   │Service    │   │Service    │
    │DB: user_db │   │Port: 8082 │   │Port: 8083 │
    └────────────┘   │DB:vehicle │   │DB:product │
                     │   _db     │   │   _db     │
                     └───────────┘   └───────────┘
           │               │               │
           └───────────────┼───────────────┘
                           │
                    ┌──────▼──────┐
                    │  RabbitMQ   │
                    │Message Broker│
                    │ Port: 5672  │
                    └─────────────┘
```

## Core Requirements

### Functional Requirements
- User registration and authentication system with JWT tokens
- BMW vehicle hierarchy management (Series → Generations → Models)
- Product catalog with category management and BMW compatibility
- Shopping cart functionality for registered users
- Basic inventory tracking
- RESTful API with proper error handling and validation

### Technical Requirements
- Spring Boot 3.2+ with modular microservice architecture
- PostgreSQL database with optimized schema design
- Redis integration for caching and session management
- Docker containerization for development environment
- Comprehensive input validation and error handling
- Proper logging and monitoring setup

## Distributed Database Architecture

### Database Per Service Strategy

Each microservice owns its data completely with no cross-database foreign keys. Services communicate via business identifiers (codes, SKUs, emails) and maintain data consistency through events.

### User Service Database (user_db)
```sql
-- User authentication and profile management
users (
    id BIGINT PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
    email VARCHAR(255) NOT NULL UNIQUE,
    password_hash VARCHAR(255) NOT NULL,
    first_name VARCHAR(100) NOT NULL,
    last_name VARCHAR(100) NOT NULL,
    phone VARCHAR(20),
    role VARCHAR(20) NOT NULL DEFAULT 'CUSTOMER',
    is_active BOOLEAN NOT NULL DEFAULT true,
    email_verified BOOLEAN NOT NULL DEFAULT false,
    created_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
    
    CONSTRAINT ck_users_role CHECK (role IN ('CUSTOMER', 'ADMIN', 'SUPER_ADMIN')),
    CONSTRAINT ck_users_email_format CHECK (email ~* '^[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Za-z]{2,}

### Service Data Relationships

#### Within-Service Relationships (Traditional Foreign Keys)
```
User Service:
- users (1) ←→ (N) user_refresh_tokens
- users (1) ←→ (N) user_vehicles
- users (1) ←→ (N) cart_items

Vehicle Service:
- bmw_series (1) ←→ (N) bmw_generations
- bmw_generations (1) ←→ (N) vehicle_compatibility_registry

Product Service:
- categories (1) ←→ (N) categories (self-referencing)
- categories (1) ←→ (N) products
- products (1) ←→ (N) product_images
- products (1) ←→ (N) product_variants
- products (1) ←→ (N) inventory
- products (1) ←→ (N) product_compatibility
- bmw_series_cache (1) ←→ (N) bmw_generations_cache
- bmw_generations_cache (1) ←→ (N) product_compatibility
```

#### Cross-Service Relationships (Business Key References)
```
User Service → Product Service:
- cart_items.product_sku → products.sku (via API calls)
- cart_items.variant_sku → product_variants.sku_suffix (via API calls)

User Service → Vehicle Service:
- user_vehicles.series_code → bmw_series.code (via API calls)
- user_vehicles.generation_code → bmw_generations.code (via API calls)

Vehicle Service → Product Service:
- vehicle_compatibility_registry.product_sku → products.sku (eventual consistency)
- bmw_series data → bmw_series_cache (event synchronization)
- bmw_generations data → bmw_generations_cache (event synchronization)
```

### Inter-Service Data Synchronization

#### Event-Driven Synchronization Pattern
```yaml
BMW Data Updates (Vehicle Service → Product Service):
  1. Admin updates BMW generation in Vehicle Service
  2. Vehicle Service publishes GenerationUpdatedEvent to RabbitMQ
  3. Product Service receives event and updates bmw_generations_cache
  4. Product Service invalidates related product compatibility caches

User Vehicle Preferences:
  1. User adds vehicle preference with series/generation codes
  2. User Service validates codes via Vehicle Service API call
  3. User Service stores preferences with business keys (not foreign keys)

Cart Operations:
  1. User adds product to cart using product SKU
  2. User Service validates product existence via Product Service API
  3. User Service checks stock availability via Product Service API
  4. Cart item stored with product SKU reference
```

### Database Indexes Strategy (Per Service)

#### User Service Indexes
```sql
-- User Service Performance Indexes
CREATE INDEX idx_users_email ON users(email);
CREATE INDEX idx_users_role ON users(role);
CREATE INDEX idx_users_active ON users(is_active);
CREATE INDEX idx_user_refresh_tokens_user ON user_refresh_tokens(user_id);
CREATE INDEX idx_user_refresh_tokens_expires ON user_refresh_tokens(expires_at);
CREATE INDEX idx_user_vehicles_user ON user_vehicles(user_id);
CREATE INDEX idx_user_vehicles_series ON user_vehicles(series_code);
CREATE INDEX idx_user_vehicles_generation ON user_vehicles(generation_code);
CREATE INDEX idx_cart_items_user ON cart_items(user_id);
CREATE INDEX idx_cart_items_product ON cart_items(product_sku);
CREATE INDEX idx_cart_items_created ON cart_items(created_at);
```

#### Vehicle Service Indexes
```sql
-- Vehicle Service Performance Indexes  
CREATE INDEX idx_bmw_series_code ON bmw_series(code);
CREATE INDEX idx_bmw_series_active ON bmw_series(is_active);
CREATE INDEX idx_bmw_generations_series ON bmw_generations(series_id);
CREATE INDEX idx_bmw_generations_code ON bmw_generations(code);
CREATE INDEX idx_bmw_generations_active ON bmw_generations(is_active);
CREATE INDEX idx_vehicle_compatibility_generation ON vehicle_compatibility_registry(generation_id);
CREATE INDEX idx_vehicle_compatibility_product ON vehicle_compatibility_registry(product_sku);
CREATE INDEX idx_vehicle_sync_events_status ON vehicle_sync_events(processing_status);
CREATE INDEX idx_vehicle_sync_events_published ON vehicle_sync_events(published_at);
```

#### Product Service Indexes
```sql
-- Product Service Performance Indexes
CREATE INDEX idx_products_category ON products(category_id);
CREATE INDEX idx_products_sku ON products(sku);
CREATE INDEX idx_products_status ON products(status);
CREATE INDEX idx_products_featured ON products(is_featured);
CREATE INDEX idx_products_search ON products USING gin(to_tsvector('english', name || ' ' || COALESCE(description, '')));
CREATE INDEX idx_product_compatibility_product ON product_compatibility(product_id);
CREATE INDEX idx_product_compatibility_generation ON product_compatibility(generation_code);
CREATE INDEX idx_inventory_product ON inventory(product_id);
CREATE INDEX idx_inventory_low_stock ON inventory(quantity_available) WHERE quantity_available <= reorder_point;
CREATE INDEX idx_bmw_series_cache_code ON bmw_series_cache(code);
CREATE INDEX idx_bmw_generations_cache_code ON bmw_generations_cache(code);
CREATE INDEX idx_bmw_generations_cache_series ON bmw_generations_cache(series_code);
```

## Microservices API Architecture

### API Gateway Endpoints (Port 8080)
```http
# Authentication (proxied to User Service)
POST /api/auth/register
POST /api/auth/login
POST /api/auth/refresh
POST /api/auth/logout
GET  /api/auth/me

# Vehicle Management (proxied to Vehicle Service)
GET /api/vehicles/series
GET /api/vehicles/series/{seriesCode}/generations
GET /api/vehicles/generations/{generationCode}
GET /api/vehicles/generations/{generationCode}/products

# Product Catalog (proxied to Product Service)
GET    /api/products
GET    /api/products/{sku}
GET    /api/products/search
GET    /api/categories
GET    /api/categories/{id}/products

# Shopping Cart (proxied to User Service)
GET    /api/cart
POST   /api/cart/items
PUT    /api/cart/items/{itemId}
DELETE /api/cart/items/{itemId}
DELETE /api/cart/clear

# Admin endpoints (role-based routing)
POST   /api/admin/products     # → Product Service
PUT    /api/admin/products/{sku} # → Product Service
POST   /api/admin/vehicles     # → Vehicle Service
```

### User Service Internal API (Port 8081)
```http
# Authentication Management
POST /internal/auth/register
POST /internal/auth/login
POST /internal/auth/refresh-token
POST /internal/auth/logout
GET  /internal/auth/validate-token
GET  /internal/users/{userId}/profile

# User Vehicle Preferences
GET    /internal/users/{userId}/vehicles
POST   /internal/users/{userId}/vehicles
PUT    /internal/users/{userId}/vehicles/{vehicleId}
DELETE /internal/users/{userId}/vehicles/{vehicleId}

# Shopping Cart Management
GET    /internal/users/{userId}/cart
POST   /internal/users/{userId}/cart/items
PUT    /internal/users/{userId}/cart/items/{itemId}
DELETE /internal/users/{userId}/cart/items/{itemId}
POST   /internal/users/{userId}/cart/validate # Validate against Product Service

# Health and Monitoring
GET /actuator/health
GET /actuator/metrics
```

### Vehicle Service Internal API (Port 8082)
```http
# BMW Hierarchy Management
GET    /internal/series
GET    /internal/series/{seriesCode}
POST   /internal/series                    # Admin only
PUT    /internal/series/{seriesCode}       # Admin only

GET    /internal/generations
GET    /internal/generations/{generationCode}
GET    /internal/series/{seriesCode}/generations
POST   /internal/generations               # Admin only
PUT    /internal/generations/{generationCode} # Admin only

# Compatibility Management
GET    /internal/compatibility/{generationCode}/products
POST   /internal/compatibility             # Admin only
PUT    /internal/compatibility/{id}        # Admin only

# Bulk Operations for Cross-Service Queries
POST   /internal/series/bulk               # Get multiple series by codes
POST   /internal/generations/bulk          # Get multiple generations by codes

# Health and Monitoring
GET /actuator/health
GET /actuator/metrics
```

### Product Service Internal API (Port 8083)
```http
# Product Catalog Management
GET    /internal/products
GET    /internal/products/{sku}
POST   /internal/products                  # Admin only
PUT    /internal/products/{sku}            # Admin only
DELETE /internal/products/{sku}            # Admin only

GET    /internal/products/search
GET    /internal/products/by-generation/{generationCode}
GET    /internal/products/featured

# Category Management
GET    /internal/categories
GET    /internal/categories/{id}
GET    /internal/categories/{id}/products
POST   /internal/categories                # Admin only
PUT    /internal/categories/{id}           # Admin only

# Inventory Management
GET    /internal/inventory/{sku}
PUT    /internal/inventory/{sku}/stock     # Update stock levels
POST   /internal/inventory/reserve         # Reserve items for cart
POST   /internal/inventory/release         # Release reserved items

# BMW Cache Management (Internal Use)
GET    /internal/bmw-cache/series
GET    /internal/bmw-cache/generations
POST   /internal/bmw-cache/sync            # Sync from Vehicle Service events

# Bulk Operations for Cross-Service Queries
POST   /internal/products/bulk             # Get multiple products by SKUs
POST   /internal/inventory/bulk            # Check stock for multiple SKUs

# Health and Monitoring
GET /actuator/health
GET /actuator/metrics
```

### Inter-Service Communication Patterns

#### Service-to-Service REST Calls
```java
// User Service calling Product Service
@Component
public class ProductServiceClient {
    
    @Autowired
    private RestTemplate restTemplate;
    
    public ProductDTO getProductBySku(String sku) {
        String url = "http://product-service:8083/internal/products/" + sku;
        return restTemplate.getForObject(url, ProductDTO.class);
    }
    
    public List<ProductDTO> getProductsBySku(List<String> skus) {
        String url = "http://product-service:8083/internal/products/bulk";
        return restTemplate.postForObject(url, skus, List.class);
    }
}
```

#### Circuit Breaker Pattern
```java
// Resilient service calls with fallback
@Component
public class VehicleServiceClient {
    
    @CircuitBreaker(name = "vehicle-service", fallbackMethod = "fallbackGetGeneration")
    public GenerationDTO getGeneration(String generationCode) {
        String url = "http://vehicle-service:8082/internal/generations/" + generationCode;
        return restTemplate.getForObject(url, GenerationDTO.class);
    }
    
    public GenerationDTO fallbackGetGeneration(String generationCode, Exception ex) {
        // Return cached data or default response
        return GenerationDTO.builder()
                .code(generationCode)
                .name("Generation data temporarily unavailable")
                .build();
    }
}
```

### Request/Response Patterns

#### Standard Service Response Format
```json
{
  "success": true,
  "data": { ... },
  "message": "Operation completed successfully",
  "timestamp": "2025-01-30T10:30:00Z",
  "serviceId": "user-service"
}
```

#### Error Response Format
```json
{
  "success": false,
  "error": {
    "code": "PRODUCT_NOT_FOUND",
    "message": "Product with SKU BMW-F30-AC-001 was not found",
    "service": "product-service",
    "details": {
      "sku": "BMW-F30-AC-001",
      "requestId": "req-123456"
    }
  },
  "timestamp": "2025-01-30T10:30:00Z"
}
```

#### Cross-Service Request Example
```json
// User Service → Product Service: Validate cart items
POST /internal/inventory/bulk
{
  "items": [
    {
      "sku": "BMW-F30-AC-001",
      "variantSku": "-BLK",
      "requestedQuantity": 2
    },
    {
      "sku": "BMW-E90-LED-002", 
      "requestedQuantity": 1
    }
  ]
}

// Product Service Response
{
  "success": true,
  "data": [
    {
      "sku": "BMW-F30-AC-001",
      "variantSku": "-BLK",
      "available": true,
      "stockLevel": 15,
      "unitPrice": 99.00
    },
    {
      "sku": "BMW-E90-LED-002",
      "available": false,
      "stockLevel": 0,
      "reason": "OUT_OF_STOCK"
    }
  ]
}
```

### Request/Response Patterns

#### Standard Response Format
```json
{
  "success": true,
  "data": { ... },
  "message": "Operation completed successfully",
  "timestamp": "2025-01-30T10:30:00Z"
}
```

#### Error Response Format
```json
{
  "success": false,
  "error": {
    "code": "VALIDATION_FAILED",
    "message": "Validation errors occurred",
    "details": [
      {
        "field": "email",
        "message": "Email format is invalid"
      }
    ]
  },
  "timestamp": "2025-01-30T10:30:00Z"
}
```

#### Paginated Response Format
```json
{
  "success": true,
  "data": [ ... ],
  "pagination": {
    "page": 0,
    "size": 20,
    "total": 150,
    "totalPages": 8,
    "hasNext": true,
    "hasPrevious": false
  }
}
```

## Microservices Service Layer Architecture

### Service Boundaries & Responsibilities

#### User Service Domain
```java
// Service Responsibilities
@Service
public class UserService {
    // User account management
    // JWT token lifecycle
    // Password security
    // User profile operations
}

@Service  
public class UserVehicleService {
    // BMW vehicle preferences (using codes)
    // Vehicle validation via Vehicle Service calls
    // User vehicle management
}

@Service
public class CartService {
    // Shopping cart CRUD operations
    // Stock validation via Product Service calls  
    // Price calculation and totals
    // Cart cleanup and persistence
}
```

#### Vehicle Service Domain
```java
// Service Responsibilities
@Service
public class BMWHierarchyService {
    // BMW series and generations master data
    // Hierarchy validation and lookup
    // Admin management of BMW data
}

@Service
public class CompatibilityService {
    // Product-to-generation compatibility registry
    // Compatibility rule management
    // Cross-service compatibility queries
}

@Service
public class VehicleSyncService {
    // Event publishing for BMW data changes
    // Synchronization with Product Service
    // Data consistency management
}
```

#### Product Service Domain
```java
// Service Responsibilities
@Service
public class ProductCatalogService {
    // Product CRUD operations
    // Category management
    // Product search and filtering
    // SKU management and validation
}

@Service
public class InventoryService {
    // Stock level tracking
    // Quantity reservations
    // Stock movement logging
    // Reorder point management
}

@Service
public class BMWCacheService {
    // BMW data cache management
    // Event-driven cache updates
    // Cache invalidation strategies
    // Fast compatibility lookups
}

@Service
public class ProductCompatibilityService {
    // Product-to-BMW compatibility
    // Compatibility validation using cached data
    // Cross-service compatibility checks
}
```

### Inter-Service Communication Architecture

#### Synchronous Communication (REST)
```yaml
Direct API Calls:
  User Service → Product Service:
    - Validate cart items and check stock
    - Get product details for cart display
    - Price verification for checkout
    
  User Service → Vehicle Service:
    - Validate BMW model selections
    - Get generation details for user preferences
    
  Product Service → Vehicle Service:
    - Validate compatibility data
    - Sync BMW hierarchy changes
    
  API Gateway → All Services:
    - Route requests based on path patterns
    - Handle authentication and authorization
    - Rate limiting and request validation
```

#### Asynchronous Communication (RabbitMQ Events)
```yaml
Event Types:
  Vehicle Service Events:
    - BMWSeriesUpdated: When series data changes
    - BMWGenerationUpdated: When generation data changes
    - CompatibilityRuleChanged: When compatibility rules change
    
  Product Service Events:
    - ProductCreated: When new products are added
    - StockLevelChanged: When inventory levels change
    - ProductPriceUpdated: When product prices change
    
  User Service Events:
    - UserRegistered: When new users sign up
    - CartUpdated: When cart contents change
    - UserVehicleAdded: When users add vehicle preferences

Message Flow Examples:
  BMW Data Update:
    Vehicle Service → RabbitMQ → Product Service (cache update)
    
  Stock Level Change:
    Product Service → RabbitMQ → Admin Dashboard (notification)
    
  User Registration:
    User Service → RabbitMQ → Notification Service (welcome email)
```

### Service Layer Design Patterns

#### Repository Pattern (Per Service)
```java
// User Service Repository
@Repository
public interface UserRepository extends JpaRepository<User, Long> {
    Optional<User> findByEmail(String email);
    List<User> findByRole(UserRole role);
}

// Vehicle Service Repository
@Repository
public interface BMWGenerationRepository extends JpaRepository<BMWGeneration, Long> {
    Optional<BMWGeneration> findByCode(String code);
    List<BMWGeneration> findBySeriesIdAndIsActiveTrue(Long seriesId);
}

// Product Service Repository
@Repository
public interface ProductRepository extends JpaRepository<Product, Long> {
    Optional<Product> findBySku(String sku);
    
    @Query("SELECT p FROM Product p JOIN p.compatibility pc WHERE pc.generationCode = :generationCode")
    List<Product> findByGenerationCode(@Param("generationCode") String generationCode);
}
```

#### Transaction Boundaries (Service-Specific)
```java
// User Service - Single database transactions
@Service
@Transactional
public class UserService {
    
    @Transactional
    public User registerUser(UserRegistrationRequest request) {
        // All operations within User Service database
        User user = createUser(request);
        sendVerificationEmail(user);
        publishUserRegisteredEvent(user);
        return user;
    }
}

// Product Service - Local transactions with eventual consistency
@Service  
@Transactional
public class ProductService {
    
    @Transactional
    public Product createProduct(CreateProductRequest request) {
        // Validate BMW compatibility via API call (outside transaction)
        validateCompatibility(request.getGenerationCodes());
        
        // Local database transaction
        Product product = saveProduct(request);
        createInitialInventory(product);
        publishProductCreatedEvent(product);
        return product;
    }
}
```

#### Event Publishing Pattern
```java
// Vehicle Service - Event publishing
@Service
public class BMWHierarchyService {
    
    @Autowired
    private RabbitTemplate rabbitTemplate;
    
    @Transactional
    public BMWGeneration updateGeneration(String generationCode, UpdateGenerationRequest request) {
        BMWGeneration generation = generationRepository.findByCode(generationCode)
                .orElseThrow(() -> new GenerationNotFoundException(generationCode));
                
        // Update local data
        generation.setName(request.getName());
        generation.setYearEnd(request.getYearEnd());
        BMWGeneration updated = generationRepository.save(generation);
        
        // Publish event for other services
        BMWGenerationUpdatedEvent event = BMWGenerationUpdatedEvent.builder()
                .generationCode(updated.getCode())
                .seriesCode(updated.getSeries().getCode())
                .name(updated.getName())
                .yearStart(updated.getYearStart())
                .yearEnd(updated.getYearEnd())
                .bodyCode(updated.getBodyCodes())
                .build();
                
        rabbitTemplate.convertAndSend("vehicle.generation.updated", event);
        
        return updated;
    }
}
```

#### Event Listening Pattern
```java
// Product Service - Event listening
@Component
public class BMWCacheEventListener {
    
    @Autowired
    private BMWCacheService bmwCacheService;
    
    @RabbitListener(queues = "product.vehicle.generation.updated")
    public void handleGenerationUpdated(BMWGenerationUpdatedEvent event) {
        try {
            bmwCacheService.updateGenerationCache(event);
            log.info("Updated BMW generation cache for: {}", event.getGenerationCode());
        } catch (Exception e) {
            log.error("Failed to update generation cache for: {}", event.getGenerationCode(), e);
            // Send to dead letter queue for retry
            throw e;
        }
    }
}
```

### Cross-Service Data Validation

#### Validation Strategy
```java
// User Service - Validating BMW preferences
@Service
public class UserVehicleService {
    
    @Autowired
    private VehicleServiceClient vehicleClient;
    
    public UserVehicle addUserVehicle(Long userId, AddVehicleRequest request) {
        // Validate BMW data exists via Vehicle Service
        GenerationDTO generation = vehicleClient.getGeneration(request.getGenerationCode());
        if (generation == null) {
            throw new InvalidGenerationException(request.getGenerationCode());
        }
        
        // Store with business keys, not foreign keys
        UserVehicle vehicle = UserVehicle.builder()
                .userId(userId)
                .seriesCode(generation.getSeriesCode())
                .generationCode(generation.getCode())
                .year(request.getYear())
                .modelVariant(request.getModelVariant())
                .build();
                
        return userVehicleRepository.save(vehicle);
    }
}
```

### Error Handling & Service Resilience

#### Circuit Breaker Implementation
```java
@Component
public class ProductServiceClient {
    
    @CircuitBreaker(name = "product-service", fallbackMethod = "fallbackGetProduct")
    @Retry(name = "product-service")
    @TimeLimiter(name = "product-service")
    public CompletableFuture<ProductDTO> getProductAsync(String sku) {
        return CompletableFuture.supplyAsync(() -> {
            return restTemplate.getForObject(
                "http://product-service:8083/internal/products/" + sku, 
                ProductDTO.class
            );
        });
    }
    
    public CompletableFuture<ProductDTO> fallbackGetProduct(String sku, Exception ex) {
        return CompletableFuture.completedFuture(
            ProductDTO.builder()
                .sku(sku)
                .name("Product temporarily unavailable")
                .available(false)
                .build()
        );
    }
}
```

## Authentication Architecture

### JWT Token Strategy
- **Access Tokens**: 15-minute expiry, contains user ID and role
- **Refresh Tokens**: 7-day expiry, stored in database with revocation capability
- **Token Signing**: RS256 algorithm with rotating keys

### Security Flow
1. **Registration**: Create user → Send verification email → Activate account
2. **Login**: Validate credentials → Generate token pair → Return tokens
3. **API Access**: Validate access token → Process request
4. **Token Refresh**: Validate refresh token → Generate new token pair
5. **Logout**: Revoke refresh token → Blacklist access token

### Role-Based Authorization
- **CUSTOMER**: Cart operations, profile management, order viewing
- **ADMIN**: Product management, inventory updates, order management
- **SUPER_ADMIN**: User management, system configuration

## Validation Rules

### User Validation
```yaml
Registration:
  email: Required, valid format, unique, max 255 chars
  password: Min 8 chars, 1 uppercase, 1 number, 1 special char
  firstName: Required, 2-100 chars, letters only
  lastName: Required, 2-100 chars, letters only
  phone: Optional, Romanian format validation

Profile Updates:
  All fields optional except email uniqueness
  Password changes require current password verification
```

### Product Validation
```yaml
Product Creation:
  name: Required, 3-255 chars, unique within category
  sku: Required, alphanumeric + dash, 6-50 chars, globally unique
  basePrice: Required, positive decimal, max 2 decimal places
  categoryId: Required, must exist in categories table
  description: Optional, max 2000 chars
  
BMW Compatibility:
  generationId: Required, must exist in bmw_generations table
  notes: Optional, max 500 chars
  At least one generation must be assigned per product
```

### Cart Validation
```yaml
Add to Cart:
  productId: Required, must exist and be active
  variantId: Optional, must belong to specified product if provided
  quantity: Required, 1-99, must not exceed available stock
  
Update Cart:
  quantity: Same as add to cart rules
  Stock availability revalidated on every update
```

## Caching Strategy

### Redis Cache Usage
- **Product Catalog**: Cache frequently accessed products and categories
- **BMW Hierarchy**: Cache series and generations data
- **User Sessions**: Store JWT token metadata
- **Cart Data**: Backup cart data for session persistence

### Cache Keys Pattern
```
products:all:{page}:{size}:{filters_hash}
products:by_id:{productId}
products:category:{categoryId}:{page}:{size}
bmw:series:all
bmw:generations:series:{seriesId}
user:cart:{userId}
```

### Cache Invalidation Strategy
- **Product Updates**: Clear related product and category caches
- **Inventory Changes**: Clear product availability caches
- **User Changes**: Clear user-specific caches
- **TTL Settings**: Short TTL for dynamic data, longer for static data

## Docker Configuration

### Development Environment Setup
```yaml
Services Required:
  - PostgreSQL 15: Primary database
  - Redis 7: Caching and sessions
  - Spring Boot App: Main application
  - pgAdmin: Database management (optional)

Port Mapping:
  - PostgreSQL: 5432:5432
  - Redis: 6379:6379
  - Spring Boot: 8080:8080
  - pgAdmin: 8081:80

Volume Mapping:
  - PostgreSQL data persistence
  - Application logs
  - Uploaded images (temporary)
```

### Environment Variables
```yaml
Database:
  - DATABASE_URL
  - DATABASE_USERNAME  
  - DATABASE_PASSWORD

Redis:
  - REDIS_URL
  - REDIS_PASSWORD

Application:
  - JWT_SECRET
  - JWT_ACCESS_TOKEN_EXPIRY
  - JWT_REFRESH_TOKEN_EXPIRY
  - BCRYPT_ROUNDS

Logging:
  - LOG_LEVEL
  - LOG_FILE_PATH
```

## Testing Strategy

### Unit Testing Focus
- **Service Layer**: Business logic validation, edge cases
- **Repository Layer**: Custom queries, data integrity
- **Utility Classes**: Validation helpers, formatters
- **Security Components**: JWT handling, password validation

### Integration Testing Scope
- **Database Operations**: CRUD operations with real database
- **Authentication Flow**: Complete login/logout cycles
- **Cart Operations**: Multi-step cart management
- **Product Search**: Complex filtering and sorting

### Test Data Requirements
- **BMW Hierarchy**: Complete series and generations data
- **Product Catalog**: Products across all categories with compatibility
- **User Accounts**: Various roles and states
- **Cart Scenarios**: Different cart states and edge cases

## Performance Considerations

### Database Optimization
- **Query Optimization**: Use appropriate indexes for frequent queries
- **Connection Pooling**: Configure HikariCP for optimal throughput
- **Lazy Loading**: Avoid N+1 queries with proper fetch strategies
- **Pagination**: Implement cursor-based pagination for large datasets

### Application Performance
- **Caching**: Implement multi-level caching strategy
- **Async Processing**: Use for non-critical operations
- **Resource Management**: Proper connection and memory management
- **Monitoring**: Track response times and resource usage

## Implementation Milestones

### Milestone 1: Infrastructure Foundation (Week 1-2)
**Deliverables:**
- Docker Compose setup with PostgreSQL, Redis, and RabbitMQ
- Three Spring Boot 3.2+ project structures (User, Vehicle, Product services)
- API Gateway setup with Spring Cloud Gateway
- Service discovery and basic routing configuration
- Health check endpoints for all services
- Database migration framework setup for each service

**Success Criteria:**
- ✅ All services start successfully in Docker containers
- ✅ API Gateway routes requests to appropriate services
- ✅ Database connections established for each service
- ✅ RabbitMQ message broker operational
- ✅ Health checks accessible via API Gateway

### Milestone 2: Service Foundations & Databases (Week 2-3)
**Deliverables:**
- Complete database schema implementation for all three services
- JPA entities for all tables within each service boundary
- Repository interfaces with basic CRUD operations
- Database seeding with BMW hierarchy data in Vehicle Service
- Basic REST endpoints for each service (internal APIs)
- Service-to-service communication setup

**Success Criteria:**
- ✅ All service databases created with proper isolation
- ✅ BMW series and generations data loaded in Vehicle Service
- ✅ Services can communicate with each other via REST calls
- ✅ Database constraints and relationships working within services
- ✅ Basic CRUD operations functional in each service

### Milestone 3: Authentication & Security (Week 3-4)
**Deliverables:**
- User registration and login in User Service
- JWT token generation, validation, and refresh functionality
- API Gateway security configuration with JWT validation
- Role-based authorization across service boundaries
- Password hashing and security best practices
- Cross-service authentication token propagation

**Success Criteria:**
- ✅ Users can register and login via API Gateway
- ✅ JWT tokens work for authentication across all services
- ✅ API Gateway properly validates and forwards authentication
- ✅ Role-based access control functional
- ✅ Secure password handling implemented

### Milestone 4: BMW Data & Cross-Service Sync (Week 4-5)
**Deliverables:**
- BMW hierarchy management in Vehicle Service
- Event-driven synchronization with RabbitMQ
- BMW data cache implementation in Product Service
- Event listeners for BMW data updates
- Cross-service BMW data validation
- Compatibility system foundation

**Success Criteria:**
- ✅ BMW data changes in Vehicle Service propagate to Product Service
- ✅ Event-driven synchronization working reliably
- ✅ BMW cache in Product Service stays synchronized
- ✅ Cross-service BMW data validation functional
- ✅ Compatibility queries working with cached data

### Milestone 5: Product Catalog & Inventory (Week 5-6)
**Deliverables:**
- Product catalog management in Product Service
- Category hierarchy and product CRUD operations
- BMW compatibility system using cached vehicle data
- Basic inventory tracking and stock management
- Product search and filtering capabilities
- Image upload and management foundation

**Success Criteria:**
- ✅ Products can be created with BMW compatibility
- ✅ Product catalog operations working via API Gateway
- ✅ Inventory tracking operational with stock validation
- ✅ BMW compatibility validation using cached data
- ✅ Product search and filtering functional

### Milestone 6: Shopping Cart & Integration (Week 6-7)
**Deliverables:**
- Shopping cart functionality in User Service
- Cross-service stock validation for cart items
- Price calculation with Product Service integration
- Cart persistence and session management
- Stock reservation system coordination
- Error handling and service resilience patterns

**Success Criteria:**
- ✅ Users can add/remove items from cart via API Gateway
- ✅ Cart validation works across User and Product services
- ✅ Stock levels properly checked and reserved
- ✅ Cart totals calculated correctly with current prices
- ✅ Service failures handled gracefully with fallbacks

### Milestone 7: Polish & Production Readiness (Week 7-8)
**Deliverables:**
- Comprehensive error handling across all services
- Service resilience patterns (circuit breakers, retries)
- Distributed caching with Redis integration
- API documentation for all services (OpenAPI/Swagger)
- Monitoring and logging setup for distributed system
- Performance optimization and load testing

**Success Criteria:**
- ✅ All error scenarios handled gracefully across services
- ✅ Services resilient to network failures and timeouts
- ✅ Caching improving response times across services
- ✅ Complete API documentation available
- ✅ Monitoring and logging operational for all services
- ✅ Performance targets met for cross-service operations

## Success Metrics

### Technical Metrics
- **Cross-Service Communication**: < 100ms for internal API calls
- **Event Processing**: < 5 seconds for BMW data synchronization
- **API Gateway Performance**: < 50ms routing overhead
- **Cache Hit Rate**: > 80% for BMW data in Product Service
- **Service Availability**: 99%+ uptime for each individual service

### Functional Metrics
- **Authentication**: Successful login/logout across service boundaries
- **Data Consistency**: BMW data synchronized within 5 seconds
- **Cart Operations**: Accurate stock validation across services
- **BMW Compatibility**: Correct compatibility data using cached BMW hierarchy

### Architectural Metrics
- **Service Independence**: Each service deployable independently
- **Database Isolation**: No cross-database queries or foreign keys
- **Event-Driven Sync**: Reliable message processing with dead letter queues
- **Fault Tolerance**: Graceful degradation when services are unavailable

### Quality Metrics
- **Code Quality**: Clean service boundaries and proper separation of concerns
- **Documentation**: Complete API documentation for all service endpoints
- **Security**: JWT authentication working across distributed system
- **Maintainability**: Clear service responsibilities and minimal coupling

---

**This Phase 1 microservices foundation will provide a robust, scalable, and truly distributed architecture that serves as the backbone for all subsequent phases. The increased complexity pays dividends in learning enterprise patterns and creating a production-ready system architecture.**

---

**This Phase 1 foundation will provide a solid, scalable base for the complete BeamerParts e-commerce platform. Each subsequent phase will build upon these core services to add more sophisticated functionality.**)
);

-- JWT refresh token management
```sql
user_refresh_tokens (
    id BIGINT PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
    user_id BIGINT NOT NULL REFERENCES users(id) ON DELETE CASCADE,
    token_hash VARCHAR(255) NOT NULL UNIQUE,
    expires_at TIMESTAMP NOT NULL,
    created_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
    is_revoked BOOLEAN NOT NULL DEFAULT false
);

-- User's BMW vehicle preferences (uses codes, not foreign keys)
user_vehicles (
    id BIGINT PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
    user_id BIGINT NOT NULL REFERENCES users(id) ON DELETE CASCADE,
    series_code VARCHAR(10) NOT NULL, -- '3', 'X5', etc.
    generation_code VARCHAR(20) NOT NULL, -- 'F30', 'E90', etc.
    year INTEGER,
    model_variant VARCHAR(100), -- '320i', '330d', etc.
    is_primary BOOLEAN NOT NULL DEFAULT false,
    created_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
    
    CONSTRAINT ck_user_vehicles_year CHECK (year IS NULL OR (year >= 1950 AND year <= EXTRACT(YEAR FROM CURRENT_DATE) + 2))
);

-- Shopping cart (uses product SKUs, not foreign keys)
cart_items (
    id BIGINT PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
    user_id BIGINT NOT NULL REFERENCES users(id) ON DELETE CASCADE,
    product_sku VARCHAR(50) NOT NULL, -- 'BMW-F30-AC-001'
    variant_sku VARCHAR(20), -- '-BLK', '-CF', etc.
    quantity INTEGER NOT NULL,
    unit_price DECIMAL(10,2) NOT NULL, -- Price snapshot
    created_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
    
    CONSTRAINT ck_cart_items_quantity CHECK (quantity > 0 AND quantity <= 99),
    CONSTRAINT ck_cart_items_price CHECK (unit_price >= 0),
    CONSTRAINT uk_cart_items_user_product_variant UNIQUE (user_id, product_sku, variant_sku)
);
```

### Vehicle Service Database (vehicle_db)
```sql
-- BMW Series master data
bmw_series (
    id BIGINT PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
    name VARCHAR(50) NOT NULL, -- 'Seria 3', 'X5', etc.
    code VARCHAR(10) NOT NULL UNIQUE, -- '3', 'X5', etc.
    display_order INTEGER NOT NULL,
    is_active BOOLEAN NOT NULL DEFAULT true,
    created_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP
);

-- BMW Generations master data  
bmw_generations (
    id BIGINT PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
    series_id BIGINT NOT NULL REFERENCES bmw_series(id),
    name VARCHAR(100) NOT NULL, -- 'E46', 'F30/F31/F34/F35', etc.
    code VARCHAR(20) NOT NULL, -- 'E46', 'F30', etc.
    year_start INTEGER NOT NULL,
    year_end INTEGER, -- NULL for current generation
    body_codes TEXT[], -- ['F30', 'F31', 'F34', 'F35'] for variants
    is_active BOOLEAN NOT NULL DEFAULT true,
    created_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
    
    CONSTRAINT uk_bmw_generations_series_code UNIQUE (series_id, code),
    CONSTRAINT ck_bmw_generations_years CHECK (year_start > 1950 AND (year_end IS NULL OR year_end >= year_start))
);

-- Compatibility registry (uses product SKUs, not foreign keys)
vehicle_compatibility_registry (
    id BIGINT PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
    generation_id BIGINT NOT NULL REFERENCES bmw_generations(id),
    product_sku VARCHAR(50) NOT NULL, -- 'BMW-F30-AC-001'
    notes VARCHAR(500), -- 'Pentru toate modelele seria 3'
    is_verified BOOLEAN NOT NULL DEFAULT false,
    created_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
    
    CONSTRAINT uk_vehicle_compatibility UNIQUE (generation_id, product_sku)
);

-- Event publishing log for synchronization
vehicle_sync_events (
    id BIGINT PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
    event_type VARCHAR(50) NOT NULL, -- 'SERIES_UPDATED', 'GENERATION_UPDATED'
    entity_code VARCHAR(50) NOT NULL, -- Series or generation code
    event_data JSONB NOT NULL, -- Full entity data
    published_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
    processing_status VARCHAR(20) NOT NULL DEFAULT 'PENDING'
);
```



### Product Service Database (product_db)
```sql
-- Product categories
categories (
    id BIGINT PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
    name VARCHAR(100) NOT NULL,
    slug VARCHAR(100) NOT NULL UNIQUE,
    description TEXT,
    parent_id BIGINT REFERENCES categories(id),
    display_order INTEGER NOT NULL DEFAULT 0,
    is_active BOOLEAN NOT NULL DEFAULT true,
    created_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
    
    CONSTRAINT ck_categories_no_self_parent CHECK (parent_id != id)
);

-- Products table
products (
    id BIGINT PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
    name VARCHAR(255) NOT NULL,
    slug VARCHAR(255) NOT NULL UNIQUE,
    sku VARCHAR(50) NOT NULL UNIQUE, -- Primary business identifier
    description TEXT,
    short_description VARCHAR(500),
    base_price DECIMAL(10,2) NOT NULL,
    category_id BIGINT NOT NULL REFERENCES categories(id),
    brand VARCHAR(100),
    weight_grams INTEGER,
    dimensions_json JSONB, -- {"length": 10, "width": 5, "height": 2}
    is_featured BOOLEAN NOT NULL DEFAULT false,
    status VARCHAR(20) NOT NULL DEFAULT 'ACTIVE',
    created_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
    
    CONSTRAINT ck_products_price CHECK (base_price >= 0),
    CONSTRAINT ck_products_status CHECK (status IN ('ACTIVE', 'INACTIVE', 'DISCONTINUED')),
    CONSTRAINT ck_products_weight CHECK (weight_grams IS NULL OR weight_grams > 0)
);

-- Product images
product_images (
    id BIGINT PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
    product_id BIGINT NOT NULL REFERENCES products(id) ON DELETE CASCADE,
    image_url VARCHAR(500) NOT NULL,
    alt_text VARCHAR(255),
    is_primary BOOLEAN NOT NULL DEFAULT false,
    sort_order INTEGER NOT NULL DEFAULT 0,
    created_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP
);

-- Product variants
product_variants (
    id BIGINT PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
    product_id BIGINT NOT NULL REFERENCES products(id) ON DELETE CASCADE,
    name VARCHAR(100) NOT NULL, -- 'Black', 'Carbon Fiber', etc.
    sku_suffix VARCHAR(20) NOT NULL, -- '-BLK', '-CF', etc.
    price_modifier DECIMAL(10,2) NOT NULL DEFAULT 0,
    is_active BOOLEAN NOT NULL DEFAULT true,
    created_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
    
    CONSTRAINT uk_product_variants_product_sku UNIQUE (product_id, sku_suffix)
);

-- Inventory management
inventory (
    id BIGINT PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
    product_id BIGINT NOT NULL REFERENCES products(id) ON DELETE CASCADE,
    variant_id BIGINT REFERENCES product_variants(id) ON DELETE CASCADE,
    quantity_available INTEGER NOT NULL DEFAULT 0,
    quantity_reserved INTEGER NOT NULL DEFAULT 0,
    minimum_stock_level INTEGER NOT NULL DEFAULT 5,
    reorder_point INTEGER NOT NULL DEFAULT 10,
    last_updated TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
    
    CONSTRAINT ck_inventory_quantities CHECK (
        quantity_available >= 0 AND 
        quantity_reserved >= 0 AND
        minimum_stock_level >= 0 AND
        reorder_point >= minimum_stock_level
    ),
    CONSTRAINT uk_inventory_product_variant UNIQUE (product_id, variant_id)
);

-- Stock movement tracking
stock_movements (
    id BIGINT PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
    product_id BIGINT NOT NULL REFERENCES products(id),
    variant_id BIGINT REFERENCES product_variants(id),
    movement_type VARCHAR(20) NOT NULL,
    quantity_change INTEGER NOT NULL,
    reason VARCHAR(100),
    reference_id VARCHAR(50), -- Order number, adjustment ID, etc.
    user_code VARCHAR(255), -- User email or identifier
    created_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
    
    CONSTRAINT ck_stock_movements_type CHECK (movement_type IN ('INCOMING', 'OUTGOING', 'ADJUSTMENT', 'RESERVED', 'RELEASED'))
);

-- Cached BMW data for fast compatibility queries
bmw_series_cache (
    code VARCHAR(10) PRIMARY KEY, -- '3', 'X5', etc.
    name VARCHAR(50) NOT NULL,
    display_order INTEGER NOT NULL,
    is_active BOOLEAN NOT NULL DEFAULT true,
    last_updated TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP
);

bmw_generations_cache (
    code VARCHAR(20) PRIMARY KEY, -- 'F30', 'E90', etc.
    series_code VARCHAR(10) NOT NULL, -- References bmw_series_cache(code)
    name VARCHAR(100) NOT NULL,
    year_start INTEGER NOT NULL,
    year_end INTEGER,
    body_codes TEXT[],
    is_active BOOLEAN NOT NULL DEFAULT true,
    last_updated TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
    
    CONSTRAINT fk_generations_cache_series FOREIGN KEY (series_code) REFERENCES bmw_series_cache(code)
);

-- Product compatibility (uses cached BMW data)
product_compatibility (
    id BIGINT PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
    product_id BIGINT NOT NULL REFERENCES products(id) ON DELETE CASCADE,
    generation_code VARCHAR(20) NOT NULL, -- References bmw_generations_cache(code)
    notes VARCHAR(500),
    is_verified BOOLEAN NOT NULL DEFAULT false,
    created_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
    
    CONSTRAINT uk_product_compatibility UNIQUE (product_id, generation_code),
    CONSTRAINT fk_product_compatibility_generation FOREIGN KEY (generation_code) REFERENCES bmw_generations_cache(code)
);
```

### Database Relationships Summary
```
users (1) ←→ (N) user_refresh_tokens
users (1) ←→ (N) user_vehicles
users (1) ←→ (N) cart_items

bmw_series (1) ←→ (N) bmw_generations
bmw_series (1) ←→ (N) user_vehicles
bmw_generations (1) ←→ (N) user_vehicles
bmw_generations (1) ←→ (N) product_compatibility

categories (1) ←→ (N) categories (self-referencing)
categories (1) ←→ (N) products

products (1) ←→ (N) product_images
products (1) ←→ (N) product_variants
products (1) ←→ (N) product_compatibility
products (1) ←→ (N) inventory
products (1) ←→ (N) stock_movements
products (1) ←→ (N) cart_items

product_variants (1) ←→ (N) inventory
product_variants (1) ←→ (N) stock_movements
product_variants (1) ←→ (N) cart_items
```

### Database Indexes Strategy
```sql
-- Performance indexes for frequent queries
CREATE INDEX idx_users_email ON users(email);
CREATE INDEX idx_users_role ON users(role);

CREATE INDEX idx_bmw_generations_series ON bmw_generations(series_id);
CREATE INDEX idx_bmw_generations_active ON bmw_generations(is_active);

CREATE INDEX idx_products_category ON products(category_id);
CREATE INDEX idx_products_status ON products(status);
CREATE INDEX idx_products_featured ON products(is_featured);
CREATE INDEX idx_products_search ON products USING gin(to_tsvector('english', name || ' ' || COALESCE(description, '')));

CREATE INDEX idx_product_compatibility_generation ON product_compatibility(generation_id);
CREATE INDEX idx_product_compatibility_product ON product_compatibility(product_id);

CREATE INDEX idx_inventory_product ON inventory(product_id);
CREATE INDEX idx_inventory_low_stock ON inventory(quantity_available) WHERE quantity_available <= reorder_point;

CREATE INDEX idx_cart_items_user ON cart_items(user_id);
CREATE INDEX idx_cart_items_created ON cart_items(created_at);
```

## API Architecture

### Authentication Endpoints
```http
POST /api/auth/register
POST /api/auth/login
POST /api/auth/refresh
POST /api/auth/logout
GET  /api/auth/me
```

### Vehicle Management Endpoints
```http
GET /api/vehicles/series
GET /api/vehicles/series/{seriesId}/generations
GET /api/vehicles/generations/{generationId}/compatible-products
```

### Product Catalog Endpoints
```http
GET    /api/products
GET    /api/products/{id}
GET    /api/products/search
GET    /api/categories
GET    /api/categories/{id}
GET    /api/categories/{id}/products

# Admin endpoints
POST   /api/admin/products
PUT    /api/admin/products/{id}
DELETE /api/admin/products/{id}
POST   /api/admin/products/{id}/images
```

### Shopping Cart Endpoints
```http
GET    /api/cart
POST   /api/cart/items
PUT    /api/cart/items/{itemId}
DELETE /api/cart/items/{itemId}
DELETE /api/cart/clear
```

### Request/Response Patterns

#### Standard Response Format
```json
{
  "success": true,
  "data": { ... },
  "message": "Operation completed successfully",
  "timestamp": "2025-01-30T10:30:00Z"
}
```

#### Error Response Format
```json
{
  "success": false,
  "error": {
    "code": "VALIDATION_FAILED",
    "message": "Validation errors occurred",
    "details": [
      {
        "field": "email",
        "message": "Email format is invalid"
      }
    ]
  },
  "timestamp": "2025-01-30T10:30:00Z"
}
```

#### Paginated Response Format
```json
{
  "success": true,
  "data": [ ... ],
  "pagination": {
    "page": 0,
    "size": 20,
    "total": 150,
    "totalPages": 8,
    "hasNext": true,
    "hasPrevious": false
  }
}
```

## Service Layer Architecture

### Core Services Design

#### UserService Responsibilities
- User registration with email verification
- Authentication and JWT token management
- Password hashing and validation
- User profile management
- Refresh token lifecycle management

#### VehicleService Responsibilities
- BMW hierarchy data management
- Vehicle compatibility validation
- User vehicle preferences
- Generation and series lookup operations

#### ProductService Responsibilities
- Product CRUD operations
- Category management
- Product search and filtering
- BMW compatibility management
- Featured product management

#### InventoryService Responsibilities
- Stock level tracking
- Quantity reservations for cart items
- Low stock alerts
- Stock movement logging
- Reorder point management

#### CartService Responsibilities
- Cart item CRUD operations
- Price calculations and totals
- Stock availability validation
- Cart cleanup for expired items
- User cart persistence

### Service Layer Patterns

#### Transaction Boundaries
- User registration: Single transaction for user + initial setup
- Add to cart: Transaction for validation + stock reservation + cart update
- Product creation: Transaction for product + images + compatibility + inventory

#### Validation Strategy
- **Controller Level**: Request format validation, authentication
- **Service Level**: Business rule validation, cross-entity constraints
- **Repository Level**: Database constraints and referential integrity

#### Error Handling Approach
- **Custom Exceptions**: Domain-specific exceptions for business rule violations
- **Global Exception Handler**: Consistent error response formatting
- **Validation Errors**: Field-level error details for client feedback

## Authentication Architecture

### JWT Token Strategy
- **Access Tokens**: 15-minute expiry, contains user ID and role
- **Refresh Tokens**: 7-day expiry, stored in database with revocation capability
- **Token Signing**: RS256 algorithm with rotating keys

### Security Flow
1. **Registration**: Create user → Send verification email → Activate account
2. **Login**: Validate credentials → Generate token pair → Return tokens
3. **API Access**: Validate access token → Process request
4. **Token Refresh**: Validate refresh token → Generate new token pair
5. **Logout**: Revoke refresh token → Blacklist access token

### Role-Based Authorization
- **CUSTOMER**: Cart operations, profile management, order viewing
- **ADMIN**: Product management, inventory updates, order management
- **SUPER_ADMIN**: User management, system configuration

## Validation Rules

### User Validation
```yaml
Registration:
  email: Required, valid format, unique, max 255 chars
  password: Min 8 chars, 1 uppercase, 1 number, 1 special char
  firstName: Required, 2-100 chars, letters only
  lastName: Required, 2-100 chars, letters only
  phone: Optional, Romanian format validation

Profile Updates:
  All fields optional except email uniqueness
  Password changes require current password verification
```

### Product Validation
```yaml
Product Creation:
  name: Required, 3-255 chars, unique within category
  sku: Required, alphanumeric + dash, 6-50 chars, globally unique
  basePrice: Required, positive decimal, max 2 decimal places
  categoryId: Required, must exist in categories table
  description: Optional, max 2000 chars
  
BMW Compatibility:
  generationId: Required, must exist in bmw_generations table
  notes: Optional, max 500 chars
  At least one generation must be assigned per product
```

### Cart Validation
```yaml
Add to Cart:
  productId: Required, must exist and be active
  variantId: Optional, must belong to specified product if provided
  quantity: Required, 1-99, must not exceed available stock
  
Update Cart:
  quantity: Same as add to cart rules
  Stock availability revalidated on every update
```

## Caching Strategy

### Redis Cache Usage
- **Product Catalog**: Cache frequently accessed products and categories
- **BMW Hierarchy**: Cache series and generations data
- **User Sessions**: Store JWT token metadata
- **Cart Data**: Backup cart data for session persistence

### Cache Keys Pattern
```
products:all:{page}:{size}:{filters_hash}
products:by_id:{productId}
products:category:{categoryId}:{page}:{size}
bmw:series:all
bmw:generations:series:{seriesId}
user:cart:{userId}
```

### Cache Invalidation Strategy
- **Product Updates**: Clear related product and category caches
- **Inventory Changes**: Clear product availability caches
- **User Changes**: Clear user-specific caches
- **TTL Settings**: Short TTL for dynamic data, longer for static data

## Docker Configuration

### Development Environment Setup
```yaml
Services Required:
  - PostgreSQL 15: Primary database
  - Redis 7: Caching and sessions
  - Spring Boot App: Main application
  - pgAdmin: Database management (optional)

Port Mapping:
  - PostgreSQL: 5432:5432
  - Redis: 6379:6379
  - Spring Boot: 8080:8080
  - pgAdmin: 8081:80

Volume Mapping:
  - PostgreSQL data persistence
  - Application logs
  - Uploaded images (temporary)
```

### Environment Variables
```yaml
Database:
  - DATABASE_URL
  - DATABASE_USERNAME  
  - DATABASE_PASSWORD

Redis:
  - REDIS_URL
  - REDIS_PASSWORD

Application:
  - JWT_SECRET
  - JWT_ACCESS_TOKEN_EXPIRY
  - JWT_REFRESH_TOKEN_EXPIRY
  - BCRYPT_ROUNDS

Logging:
  - LOG_LEVEL
  - LOG_FILE_PATH
```

## Testing Strategy

### Unit Testing Focus
- **Service Layer**: Business logic validation, edge cases
- **Repository Layer**: Custom queries, data integrity
- **Utility Classes**: Validation helpers, formatters
- **Security Components**: JWT handling, password validation

### Integration Testing Scope
- **Database Operations**: CRUD operations with real database
- **Authentication Flow**: Complete login/logout cycles
- **Cart Operations**: Multi-step cart management
- **Product Search**: Complex filtering and sorting

### Test Data Requirements
- **BMW Hierarchy**: Complete series and generations data
- **Product Catalog**: Products across all categories with compatibility
- **User Accounts**: Various roles and states
- **Cart Scenarios**: Different cart states and edge cases

## Performance Considerations

### Database Optimization
- **Query Optimization**: Use appropriate indexes for frequent queries
- **Connection Pooling**: Configure HikariCP for optimal throughput
- **Lazy Loading**: Avoid N+1 queries with proper fetch strategies
- **Pagination**: Implement cursor-based pagination for large datasets

### Application Performance
- **Caching**: Implement multi-level caching strategy
- **Async Processing**: Use for non-critical operations
- **Resource Management**: Proper connection and memory management
- **Monitoring**: Track response times and resource usage

## Implementation Milestones

### Milestone 1: Project Foundation (Week 1)
**Deliverables:**
- Spring Boot 3.2+ project structure with proper modules
- PostgreSQL database setup with Docker
- Database migration framework configured
- Basic project configuration and profiles

**Success Criteria:**
- ✅ Application starts successfully
- ✅ Database connection established
- ✅ Basic health checks working
- ✅ Docker containers running

### Milestone 2: Database & Core Entities (Week 2)
**Deliverables:**
- Complete database schema implementation
- JPA entities for all core tables
- Repository interfaces with custom queries
- Database seeding with BMW hierarchy data

**Success Criteria:**
- ✅ All tables created with proper relationships
- ✅ BMW series and generations data loaded
- ✅ Basic CRUD operations working
- ✅ Database constraints functioning

### Milestone 3: Authentication System (Week 3)
**Deliverables:**
- User registration and login endpoints
- JWT token generation and validation
- Password hashing and security configuration
- Role-based authorization setup

**Success Criteria:**
- ✅ Users can register and login successfully
- ✅ JWT tokens working for API authentication
- ✅ Password security implemented
- ✅ Role-based access control functional

### Milestone 4: Product Catalog (Week 4)
**Deliverables:**
- Product and category management APIs
- BMW compatibility system
- Product search and filtering
- Image upload functionality
- Basic inventory tracking

**Success Criteria:**
- ✅ Products can be created and managed
- ✅ BMW compatibility validation working
- ✅ Search and filtering functional
- ✅ Inventory tracking operational

### Milestone 5: Shopping Cart (Week 5)
**Deliverables:**
- Cart management APIs
- Stock reservation system
- Price calculation logic
- Cart persistence and cleanup

**Success Criteria:**
- ✅ Users can add/remove items from cart
- ✅ Stock validation preventing overselling
- ✅ Cart totals calculated correctly
- ✅ Cart data persisted between sessions

### Milestone 6: Integration & Polish (Week 6)
**Deliverables:**
- Redis caching implementation
- Comprehensive error handling
- API documentation
- Testing suite completion
- Performance optimization

**Success Criteria:**
- ✅ Caching improving response times
- ✅ All error scenarios handled gracefully
- ✅ API documentation complete
- ✅ Test coverage meeting targets

## Success Metrics

### Technical Metrics
- **Database Performance**: Query response times < 100ms average
- **API Performance**: Endpoint response times < 200ms (95th percentile)
- **Cache Hit Rate**: > 70% for product catalog queries
- **Test Coverage**: > 80% for service layer, > 60% overall

### Functional Metrics
- **Authentication**: Successful login/logout cycles
- **Data Integrity**: No constraint violations or data corruption
- **Business Logic**: Accurate stock tracking and price calculations
- **User Experience**: Intuitive API responses and error messages

### Quality Metrics
- **Code Quality**: Clean code principles, proper separation of concerns
- **Documentation**: Complete API documentation and code comments
- **Security**: No security vulnerabilities in authentication
- **Maintainability**: Modular structure ready for future phases

---

**This Phase 1 foundation will provide a solid, scalable base for the complete BeamerParts e-commerce platform. Each subsequent phase will build upon these core services to add more sophisticated functionality.**